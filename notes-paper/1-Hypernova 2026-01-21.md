# Hypernova's Multi-folding for CCS

We explain MLE, CCS, and how to fold many CCS instances in this document.

## Background 
### Polynomials and Low-degree Extensions

1. **Low-degree polynomial**: A multivariate polynomial $g$ over a finite field $\mathbb{F}$ is called low-degree polynomial if the degree of $g$ in each variable is exponentially smaller than $|\mathbb{F}|$.

    - Low-degree $\approx$ 'poly' degree: for each variable, the degree must be "exponentially smaller" than $|\mathbb{F}|$. This typically means the degree is polylogarithmic in the field size, something like $\mathcal{O}(\log^k |\mathbb{F}|)$ for some constant $k$.

    - Why low degree:
        - Efficient Evaluation: Low-degree polynomials can be evaluated efficiently
        - Error Correction: They enable error-correcting codes - if two low-degree polynomials agree on many points, they're likely the same polynomial

2. **Low-degree Extensions (LDEs)**: Suppose $g : \{0,1\}^\ell \to \mathbb{F}$ is a function that maps $\ell$-bit elements into an element of $\mathbb{F}$. A *polynomial extension* of $g$ is a low-degree $\ell$-variate polynomial, denoted $\tilde{g}$, such that $\tilde{g}(x) = g(x)$ for all $x \in \{0,1\}^\ell$. 
    - $g$ is an arbitrary function.
        - takes $\ell$ binary values as input.
        - Outputs a field element.
        - Can be defined by a lookup table, circuit, or any other means.
        - No requirement that it be polynomial.
    - $\tilde{g}$ is a polynomial extension of $g$.
        - it's a polynomial.
        - Agrees with $g$ on all Boolean inputs: $\tilde{g}(x) = g(x)$.
        - But can be evaluated on ALL points in $\mathcal{F}$.

3. **Multilinear polynomial and multilinear extension**

**Multilinear polynomial**: A multilinear polynomial satisfies that the degree of the polynomial in each variable is at most one.

**Multilinear extension**: is a low-degree polynomial extension where the extension is a multilinear polynomial. 
Given a function $Z : \{0,1\}^\ell \to \mathbb{F}$, the multilinear extension of $Z$ is the unique multilinear polynomial $\tilde{Z} : \mathbb{F}^\ell \to \mathbb{F}$. 

It can be computed as follows.

$$
\begin{align*}
\tilde{Z}(x_1, \ldots, x_\ell) &= \sum_{e \in \{0,1\}^\ell} Z(e) \cdot \prod_{i=1}^{\ell} (x_i \cdot e_i + (1-x_i) \cdot (1-e_i)) \\
&= \sum_{e \in \{0,1\}^\ell} Z(e) \cdot \widetilde{eq}(x, e) \\
&= \langle (Z(0), \ldots, Z(2^\ell - 1)), (\widetilde{eq}(x, 0), \ldots, \widetilde{eq}(x, 2^\ell - 1)) \rangle
\end{align*}
$$

Note that $\widetilde{eq}(x, e) = \prod_{i=1}^{\ell} (e_i \cdot x_i + (1-e_i) \cdot (1-x_i))$, which is the MLE of the following function:

$$
eq(x, e) = \begin{cases}
1 & \text{if } x = e \\
0 & \text{otherwise}
\end{cases}
$$

**Lemma 1 (Sums over evaluations)**: *Consider size $\ell \in \mathbb{N}$. For multilinear polynomial $P \in \mathbb{F}[X_1, \ldots, X_\ell]$ we have that*

$$
P(X) = \sum_{x \in \{0,1\}^\ell} \widetilde{eq}(X, x) \cdot P(x).
$$

This is saying that, any multilinear polynomial can be written as a weighted sum of its evaluations on the Boolean hypercube, where the weights are given by the $\tilde{eq}$ function.

Because a multilinear polynomial in $\ell$ variables is completely determined by its $2^\ell$ values on $\{0,1\}^\ell$. 
So these evaluation points contain all the information about $P$, and Lemma 1 gives an explicit formula to reconstruct $P$ everywhere from just those Boolean evaluations.

**Lemma 2 (Schwartz-Zippel)**: *let $g : \mathbb{F}^\ell \to \mathbb{F}$ be an $\ell$-variate polynomial of total degree at most $d$. Then, on any finite set $S \subseteq \mathbb{F}$,*

$$
\Pr_{x \leftarrow S^\ell} [g(x) = 0] \leq d/|S|.
$$

### Sumcheck
Suppose there is an $\ell$-variate low-degree polynomial, $g$, where the degree of each
variable in $g$ is at most $d$.
$$ T = \sum_{x_1 \in \{0,1\}} \sum_{x_2 \in \{0,1\}} ... \sum_{x_\ell \in \{0,1\}} g(x_1, x_2, ..., x_\ell)$$
Sumcheck is a protocol between a prover and a verifier to efficiently verify that the sum of $g$'s evaluations over the Boolean hypercube equals a claimed value $T$, without the verifier computing all $2^\ell$ evaluations. 

**Efficiency:**
- **Prover**: Computes $\ell$ univariate polynomials of degree at most $d$, one per round. Total cost is $O(\ell \cdot 2^\ell)$.
- **Verifier**: Performs $O(\ell)$ checks and evaluates $g$ at a single random point. Total cost is $O(\ell \cdot d)$ (polynomial in $\ell$).
- **Communication**: $O(\ell \cdot d)$ field elements,the prover sends $\ell$ univariate polynomials.


### CCS
1. *CCS*. An $\mathcal{R}_{CCS}$ structure $\mathcal{S}$ consists of:
    - size bounds $m,n,N,\ell,t,q,d \in \mathbb{N}$, where $n>\ell$.
    - a sequence of matrices ${ \{ M_j \in \mathbb{F}^{m\times n} \} }_{j\in[t]} $.
    - a sequence of $q$ multisets ${\{S_i\}}_{i \in [q]}$.
    - a sequence of $q$ constants ${ \{ c_i \} }_{i∈[q] \in \mathbb{F}}$.
    - An $\mathcal{R}_{CCS}$ instance (structure-context tuple $(\mathcal{S}, x)$) and an $\mathcal{R}_{CCS}$ witness $w \in \mathbb{F}^{n-\ell-1}$ satisfy
    $${\sum}_{i\in[q]} c_i~ \circ_{j \in S_i}~ (M_j \cdot \vec{z}) = \vec{0}$$
    - $z = (w, 1, x) ∈ \mathbb{F}^n$, $M_j · \vec{z}$ denotes matrix-vector multiplication, $\circ$ denotes the Hadamard product between vectors, and $\vec{0}$ is an $m$-sized vector with entries equal to the additive identity in $\mathbb{F}$.

2. CCS in MLE Polynomials
    - for all $x \in \{0,1\}^s, y \in \{0,1\}^{s'}, j \in [t]$,$\tilde{M}_j(x,y) = M_j (x,y)$.
    - for all $y \in \{0,1\}^{s'}$, $\tilde{z}(y) = z(y)$.
    - each line of ${\sum}_{i\in[q]} c_i~ \circ_{j \in S_i}~ (M_j \cdot \vec{z})$(CCS equation) becomes $\sum_{i=1}^q c_i (\Pi_{j}(\sum_{y\in \{0,1\}^{s'}} \tilde{M}_i(x,y) \cdot \tilde{z}(y)))$ (MLE polynomial).

3. committed CCS (CCCS) relation $((C, x),w)$: 
    - it's CCS:
        - moreover, it's CCS in MLE polynomials: for all $x \in \{0,1\}^s$, $\sum_{i=1}^q c_i (\Pi_{j}(\sum_{y\in \{0,1\}^{s'}} \tilde{M}_i(x,y) \cdot \tilde{z}(y))) = 0$
    - it's committed: 
        - $C= Commit(pp, w)$.
        - This commitment supports homomorphic addition.

4. linear committed CCS (LCCCS) relation $((C,u,x,r,v_1, ...,v_t),w)$: 
    - it's committed: $C= Commit(pp, w)$
    - it's linear: fix randomness $r$ in the above MLE polynomials, for all $i$, $v_i = \sum_{y\in\{0,1\}^{s'}} \tilde{M}_i(r,y) \cdot \tilde{z}(y)$
    - in order to fold, $z = (w,1,x)$ in CCS $ \to z = (w,u,x)$ in LCCS.

## Multi-folding for CCS
 
- Verify CCCS and LCCCS
    - row check 
    - linear check: $\tilde{M}_i(r,y) \cdot \tilde{z}(y)$
- Fold CCCS and LCCCS to LCCCS
    1. fix CCCS at a random point $r_x$, say $\theta_1, ..., \theta_t$
    2. fix LCCCS at the same point $r_x$, say, $\sigma_1, ...,\sigma_t$
    3. linear combination: generate a randomness $\rho$,
        - combine the statement $v_1,...,v_t$ at $r_x$:
            $$ v_i' \gets \sigma_i + \rho \cdot \theta_i$$
        - combine the witness $w$ (or, the commitment): 
            $$C' \leftarrow C_1 + \rho \cdot C_2$$
        - combine $z = (\cdot, u', x')$: 
            $$u' \leftarrow u + \rho \cdot 1$$
            $$x' \leftarrow x_1 + \rho \cdot x_2$$

### The protocol:

The verifier $\mathcal{V}$ takes a linearized committed CCS instance $(C_1, u, x_1, r_x, v_1, \ldots, v_t)$ and a committed CCS instance $(C_2, x_2)$ and the prover $\mathcal{P}$, in addition to the two instances, takes witnesses to both instances, $\tilde{w}_1$ and $\tilde{w}_2$.

Let $s = \log m$ and $s' = \log n$. Let $\tilde{z}_1 = (w_1, u, x_1)$ and $\tilde{z}_2 = (w_2, 1, x_2)$.

The prover and the verifier proceed as follows.

1. $\mathcal{V} \to \mathcal{P}$: $\mathcal{V}$ samples $\gamma \leftarrow \mathbb{F}$, $\beta \leftarrow \mathbb{F}^s$, and sends them to $\mathcal{P}$.

2. $\mathcal{V}$: Sample $r'_x \leftarrow \mathbb{F}^s$.

3. $\mathcal{V} \leftrightarrow \mathcal{P}$: Run the sum-check protocol $c \leftarrow \langle \mathcal{P}, \mathcal{V}(r'_x) \rangle(g, s, d+1, \sum_{j \in [t]} \gamma^j \cdot v_j)$ for the polynomial $g(x)$, where:

$$g(x) := \left( \sum_{j \in [t]} \gamma^j \cdot L_j(x) \right) + \gamma^{t+1} \cdot Q(x)$$

$$L_j(x) := \tilde{eq}(r_x, x) \cdot \left( \sum_{y \in \{0,1\}^{s'}} \tilde{M}_j(x, y) \cdot \tilde{z}_1(y) \right)$$

$$Q(x) := \tilde{eq}(\beta, x) \cdot \left( \sum_{i=1}^{q} c_i \cdot \prod_{j \in S_i} \left( \sum_{y \in \{0,1\}^{s'}} \tilde{M}_j(x, y) \cdot \tilde{z}_2(y) \right) \right)$$

4. $\mathcal{P} \to \mathcal{V}$: $((\sigma_1, \ldots, \sigma_t), (\theta_1, \ldots, \theta_t))$, where for all $i \in [t]$:

$$\sigma_i = \sum_{y \in \{0,1\}^{s'}} \tilde{M}_i(r'_x, y) \cdot \tilde{z}_1(y)$$

$$\theta_i = \sum_{y \in \{0,1\}^{s'}} \tilde{M}_i(r'_x, y) \cdot \tilde{z}_2(y)$$

5. $\mathcal{V}$: Compute $e_1 \leftarrow \tilde{eq}(r_x, r'_x)$ and $e_2 \leftarrow \tilde{eq}(\beta, r'_x)$, and abort if:

$$c \neq \left( \sum_{j \in [t]} \gamma^j \cdot e_1 \cdot \sigma_j + \gamma^{t+1} \cdot e_2 \cdot \left( \sum_{i=1}^{q} c_i \cdot \prod_{j \in S_i} \theta_j \right) \right)$$

6. $\mathcal{V} \to \mathcal{P}$: $\mathcal{V}$ samples $\rho \leftarrow \mathbb{F}$ and sends it to $\mathcal{P}$.

7. $\mathcal{V}, \mathcal{P}$: Output the folded linearized committed CCS instance $(C', u', x', r'_x, v'_1, \ldots, v'_t)$, where for all $i \in [t]$:

$$C' \leftarrow C_1 + \rho \cdot C_2$$

$$u' \leftarrow u + \rho \cdot 1$$

$$x' \leftarrow x_1 + \rho \cdot x_2$$

$$v'_i \leftarrow \sigma_i + \rho \cdot \theta_i$$

8. $\mathcal{P}$: Output the folded witness $\tilde{w}' \leftarrow \tilde{w}_1 + \rho \cdot \tilde{w}_2$.


## Lattice-based folding
Instantiate Hypernova using lattice-based tools (additively homomorphic commitment)

1. Committed CCS to Linear CCCS
2. LCCCS x LCCCS to LCCCS
    - split (to reduce witness size)
    - fold 

We will go over the details next time.
---

